<!DOCTYPE html>

<!-- 
  Hi! Thanks for checking out this website. 
  I made it myself! 
  This website was made by hand. 
  I intentionally haven't minified anything so you can see how it all fits together.
-->

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="author" content="Clayton Ramsey" />
    <meta name="description" content="The tree of useless optimization yields questionable fruit." />
    <meta name="keywords" content="Rust, chess, chess engine" />

    <title>Blowing up my compile times for dubious benefits</title>
    <link rel="canonical" href="https://www.claytonwramsey.com/blog/fiddler-const-magic" />

    <link rel="stylesheet" type="text/css" href="/assets/main.css" />
    <link rel="stylesheet" href="/assets/hljs.css" />
    <link rel="icon" href="/assets/img/favicon.ico" />

    <script src="/assets/js/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <header>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
        <a href="/cv">CV</a>
        <a href="/blog">Blog</a>
        <a href="/recipes">Recipes</a>
      </nav>
      <h1>Blowing up my compile times for dubious benefits</h1>
      <div class="pubinfo">Clayton Ramsey - 2023-06-19</div>
    </header>
    <main>
      <p>The tree of useless optimization yields questionable fruit.</p>
      <p>
        For the last two years, I’ve been building a
        <a href="https://github.com/claytonwramsey/fiddler">chess engine called Fiddler</a>. It’s not very good by chess
        engine standards, but that’s not the point - I mostly work on it for funsies.
      </p>
      <p>
        Right now, I’m reworking my move generator to more heavily use static, precomputed data rather than runtime
        generation. Most recently, I’m moving from dynamically generating and heap-allocating the magic move generation
        table to making it a statically allocated constant. Along the way, I’ll take this opportunity to explain how
        magic move generation works, and hopefully have a little fun.
      </p>
      <p>
        <strong>Update 2023-06-22:</strong> I’ve added a few updates to handle questions that people in the comments on
        the
        <a href="https://news.ycombinator.com/item?id=36399832">Orange Website</a>
        found confusing.
      </p>
      <h2 id="a-crash-course-in-magic-moves">A crash course in magic moves</h2>
      <p>
        Chess engines are usually extremely high-performance pieces of software, and their move generators are some of
        the most high-performance parts of them. Most move generators can generate hundreds of millions of moves, per
        core, per second. Mine included!
      </p>
      <p>
        The majority of moves are made by sliding pieces - the bishop, rook, and queen - so we’ll dedicate most of our
        effort toward making that fast. The most naive approach would be to represent a board as an array of pieces, and
        then, for each piece, iterate outward along a ray, adding moves until we encounter a blocker. The problem with
        that approach is simply that it’s far too slow. In the worst case, finding the set of legal moves for a queen on
        E4 would require 27 different array accesses - and that’s just the moves for one piece! We’re going to need a
        different approach.
      </p>
      <h3 id="bitboards">Bitboards</h3>
      <p>
        We can start by representing the occupancy of a board using a
        <em>bitboard</em>: a set of squares represented by a unique 64-bit integer. Convention dictates that the
        least-significant bit should be set if the square A1 is occupied, the second-least-significant to represent B1,
        and so on until the most significant bit which represents H8.
      </p>
      <p>Here’s a quick map displaying which bit in a bitboards corresponds to a square, indexed from the LSB:</p>
      <pre class="text"><code>8 | 56 57 58 59 60 61 62 63
7 | 48 49 50 51 52 53 54 55
6 | 40 41 42 43 44 45 46 47
5 | 32 33 34 35 36 37 38 39
4 | 24 25 26 27 28 29 30 31
3 | 16 17 18 19 20 21 22 23
2 |  8  9 10 11 12 13 14 15
1 |  0  1  2  3  4  5  6  7
--+------------------------
  |  A  B  C  D  E  F  G  H</code></pre>
      <p>
        For example, consider a board with a piece on B1, G3, and C7. B1 has index 1, G3 has index 22, and C7 has index
        50, so the bitboard uniquely representing {B1, G3, C7} is
        <math
          ><mrow
            ><msup><mn>2</mn><mn>1</mn></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>22</mn></mrow></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>50</mn></mrow></msup
            ></mrow
          ></math
        >, which is equal to 1125899911036930.
      </p>
      <p>
        We can use our bitboards to compute setwise operations in
        <math
          ><mrow><mi>O</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo></mrow></math
        >
        time. Here’s a short (but not exhaustive) list of operations we can do:
      </p>
      <table>
        <thead>
          <tr class="header">
            <th>Mathematical representation</th>
            <th>Bitboard operation</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <tr class="odd">
            <td>
              <math
                ><mrow><mi>A</mi><mo>&#x0222A;</mo><mi>B</mi></mrow></math
              >
            </td>
            <td><code>a | b</code></td>
            <td></td>
          </tr>
          <tr class="even">
            <td>
              <math
                ><mrow><mi>A</mi><mo>&#x02229;</mo><mi>B</mi></mrow></math
              >
            </td>
            <td><code>a &amp; b</code></td>
            <td></td>
          </tr>
          <tr class="odd">
            <td>
              <math
                ><mrow><mi>A</mi><mi>&#x00394;</mi><mi>B</mi></mrow></math
              >
            </td>
            <td><code>a ^ b</code></td>
            <td></td>
          </tr>
          <tr class="even">
            <td>
              <math
                ><mrow
                  ><mover><mi>A</mi><mo stretchy="true">&#x000AF;</mo></mover></mrow
                ></math
              >
            </td>
            <td><code>!a</code></td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <p>
        <strong>Update 2023-06-22:</strong> I use Rust’s notation for <code>!a</code>. In C and C++, one would use
        <code>~a</code> for the bitwise not operation.
      </p>
      <h3 id="building-a-lookup-table">Building a lookup table</h3>
      <p>
        In order to get an
        <math
          ><mrow><mi>O</mi><mo stretchy="false">&#x00028;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo></mrow></math
        >
        computation of sliding moves, we can use a lookup table to find precomputed values of the set of legal moves
        given the starting square and occupancy bitboard of a board. There’s just one problem: There are an enormous
        amount of possible occupancy maps, roughly
        <math
          ><mrow
            ><msubsup
              ><mo>&#x02211;</mo><mrow><mi>n</mi><mo>&#x0003D;</mo><mn>3</mn></mrow
              ><mrow><mn>16</mn></mrow></msubsup
            ><mrow
              ><mo minsize="2.047em" maxsize="2.047em">&#x00028;</mo
              ><mfrac linethickness="0"><mn>64</mn><mi>n</mi></mfrac
              ><mo minsize="2.047em" maxsize="2.047em">&#x00029;</mo></mrow
            ></mrow
          ></math
        >
        possible occupancies containing at least two kings and a sliding piece, or about 700 trillion total boards. To
        store an 8-byte bitboard for every square and occupancy would require roughly 365 PB of data!
      </p>
      <p>
        We can use a nice trick to reduce our data consumption, though. In our naive algorithm for sliding move
        generation, we only needed to examine whether the squares that we wanted our piece to move to were occupied -
        other squares not on the same ray were irrelevant. We can do the same: we can somehow extract out the relevant
        occupancies for any square’s move generation.
      </p>
      <p>For example, these are the only relevant squares for the set of legal moves for a rook on E4:</p>
      <pre class="text"><code>8 |  .  .  .  .  .  .  .  .
7 |  .  .  .  .  x  .  .  .
6 |  .  .  .  .  x  .  .  .
5 |  .  .  .  .  x  .  .  .
4 |  .  x  x  x  .  x  x  .
3 |  .  .  .  .  x  .  .  .
2 |  .  .  .  .  x  .  .  .
1 |  .  .  .  .  .  .  .  .
--+------------------------
  |  A  B  C  D  E  F  G  H</code></pre>
      <p>
        <strong>Update 2023-06-22</strong>: We can safely ignore those squares on the edge of the board because they
        actually don’t affect what our rook can “see.” For instance, the rook will be able to to see H4 if F4 and G4 are
        empty, but whether H4 is empty does not affect whether the rook can see H4. Once we have the set of squares the
        rook can see, we can convert that to the set of squares the rook can move to by masking out all pieces of the
        same color as the rook.
      </p>
      <p>
        For each square, then, we only need to consider a small handful of occupied spots. All we need to do is store a
        lookup for every
        <code>(square, relevant_occupancy)</code> pair, which is far smaller than the previous requirement.
      </p>
      <p>
        There are at most 9 relevant occupancy bits for a bishop and 12 bits for a rook, so the total memory requirement
        for this lookup table is less than 2.4 MB. If we break out the single master lookup table into a unique lookup
        table for each attacker type and starter square, we can get a smaller total memory consumption at only 861 kB.
      </p>
      <h3 id="where-the-magic-happens">Where the magic happens</h3>
      <p>
        However, we still have to be able to convert an occupancy bitboard into an index. What we really want to do is
        to take our masked out bits and extract them into an index. On x86 architectures, the
        <code>pext</code> instruction is exactly designed to do this, but if we want it to work on any architecture,
        we’ll have to be a little more clever than that.
      </p>
      <p>
        I’ll start with a magic example, and we’ll see if that can enlighten us. Suppose we want to extract the relevant
        occupancy for a bishop on B2.
      </p>
      <p>
        Take the original masked occupancy bitboard,
        <math
          ><mrow><mi>O</mi></mrow></math
        >.
      </p>
      <pre class="text"><code>8 |  .  .  .  .  .  .  .  .
7 |  .  .  .  .  .  .  .  .
6 |  .  .  .  .  .  .  b5 .
5 |  .  .  .  .  .  b4 .  .
4 |  .  .  .  .  b3 .  .  .
3 |  .  .  .  b2 .  .  .  .
2 |  .  .  b1 .  .  .  .  .
1 |  .  .  .  .  .  .  .  .
--+------------------------
  |  A  B  C  D  E  F  G  H</code></pre>
      <p>
        Observe that
        <math
          ><mrow
            ><mi>O</mi><mo>&#x0003D;</mo><msub><mi>b</mi><mn>1</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>10</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>2</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>19</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>3</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>28</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>4</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>37</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>5</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>46</mn></mrow></msup
            ></mrow
          ></math
        >.
      </p>
      <p>
        Now, multiply
        <math
          ><mrow><mi>O</mi></mrow></math
        >
        by the magic number
        <math
          ><mrow
            ><mi>M</mi><mo>&#x0003D;</mo
            ><msup
              ><mn>2</mn><mrow><mn>17</mn></mrow></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>25</mn></mrow></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>33</mn></mrow></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>41</mn></mrow></msup
            ><mo>&#x0002B;</mo
            ><msup
              ><mn>2</mn><mrow><mn>49</mn></mrow></msup
            ></mrow
          ></math
        >.
      </p>
      <p>
        <math xmlns="" display="block"
          ><mrow
            ><mi>O</mi><mo>&#x0002A;</mo><mi>M</mi><mo>&#x0003D;</mo><msub><mi>b</mi><mn>1</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>59</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>2</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>60</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>3</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>61</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>4</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>62</mn></mrow></msup
            ><mo>&#x0002B;</mo><msub><mi>b</mi><mn>5</mn></msub
            ><msup
              ><mn>2</mn><mrow><mn>63</mn></mrow></msup
            ><mo>&#x0002B;</mo><mtext>garbage&#x000A0;on&#x000A0;other&#x000A0;exponents</mtext></mrow
          ></math
        >
      </p>
      <p>
        Using simple bitwise masking, we can then manually retrieve those packed bits near the MSB to use as our index.
        We can generate a set of 128 magic numbers (64 for bishops, 64 for rooks) which individually can be used to map
        each square and occupancy to extract its bits, and then use that operation to retrieve a pre-computed set of
        moves in constant time.
      </p>
      <p>
        <em>Side note</em>: Most of the time, there are actually collisions when using magic numbers. Collisions occur
        when our magic multiply doesn’t perfectly extract the relevant bits, but instead returns some other, bizarre
        combination of our relevant bits as the index. However, so long as the collisions map the same final moveset,
        that’s OK, so finding magics is actually pretty easy - brute force search works quite well.
      </p>
      <h2 id="getting-down-to-business">Getting down to business</h2>
      <p>
        Most engines both compute all their magic numbers as part of their startup routines. Before this week, I
        included the magic numbers as static constants and computed the entire table of movesets at startup. However,
        due to the limitations of Rust, I ended up using
        <a href="https://docs.rs/once_cell/latest/once_cell/"><code>once_cell</code></a
        >’s <code>Lazy</code> for initializing the move lookup table. This had the benefit of being really easy to
        implement, but it also meant that every time move generation was required (i.e. millions of times per second)
        the engine had to check whether the moves lookup table had already been loaded.
      </p>
      <p>
        Now, I have to rewrite it from scratch, but in “hard” mode - to make all the constants known at compile time,
        everything has to be written in a
        <code>const</code> function. This means:
      </p>
      <ul>
        <li>No allocations</li>
        <li>No printing</li>
        <li>No panicking</li>
        <li>No for loops</li>
        <li>No trait methods</li>
      </ul>
      <p>
        Let’s get right to it by describing our data layout. We begin by implementing a
        <code>Bitboard</code> by wrapping <code>u64</code>:
      </p>
      <pre class="rust"><code>#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(transparent)]
pub struct Bitboard(u64);</code></pre>
      <p>
        For every square and sliding piece type, we’ll create a structure called an
        <code>AttacksLookup</code>:
      </p>
      <pre
        class="rust"
      ><code>/// A lookup table for generating attacks via magic bitboard for one piece type and square.
struct AttacksLookup {
    /// A reference to this lookup&#39;s section of the magic attacks.
    table: &amp;&#39;static [Bitboard],
    /// The mask for extracting out the relevant occupancy map on a board.
    mask: Bitboard,
    /// The magic multiply constant for converting occupancies to indices.
    magic: u64,
    /// The shift to extract an index from a multiplied constant.
    shift: u8,
}</code></pre>
      <p>
        In order for us to have a “ragged” moves-lookup table, we don’t have each
        <code>AttacksLookup</code> own its attack set, since that would result in extremely inefficient space usage and
        an enormous increase in what will already be a very large binary. Instead, we store <em>all</em>
        of the moves-lookup tables in one giant array, and have each
        <code>AttacksLookup</code> have a reference to its section of that array.
      </p>
      <p>
        Let’s try to populate that array, staying mindful of our lack of for-loops. First, we’ll store our magic
        numbers:
      </p>
      <pre
        class="rust"
      ><code>/// A saved list of magic multiply numbers for rooks, indexed by the square they&#39;re used for.
const SAVED_ROOK_MAGICS: [u64; 64] = [
    /* 64 lines removed */
];</code></pre>
      <p>
        These magic numbers can be found offline via trial and error, but there are also public records of magic
        numbers. For example, the Chess Programming wiki
        <a href="https://www.chessprogramming.org/Best_Magics_so_far">keeps a record of magic numbers</a>.
      </p>
      <p>
        Next, we need to know how much storage to allocate for all the rook moves. We do this by first storing a table
        of how many entries are needed for each square to calculate our moves.
      </p>
      <pre
        class="rust"
      ><code>/// Log-base-2 of the number of entries required in the moves-lookup table for each square.
const ROOK_BITS: [u8; 64] = [
    12, 11, 11, 11, 11, 11, 11, 12, // rank 1
    11, 10, 10, 10, 10, 10, 10, 11, // 2
    11, 10, 10, 10, 10, 10, 10, 11, // 3
    11, 10, 10, 10, 10, 10, 10, 11, // 4
    11, 10, 10, 10, 10, 10, 10, 11, // 5
    11, 10, 10, 10, 10, 10, 10, 11, // 6
    10, 9, 9, 9, 9, 9, 9, 10, // 7
    11, 10, 10, 10, 10, 11, 10, 11, // 8
];</code></pre>
      <p>
        You may notice something odd happening on ranks 7 and 8: the number of bits required for some of the squares is
        1 lower than their mask. This is intentional! As it turns out, certain magic numbers will yield just the right
        set of hash collisions so that you can use half as many entries are there are occupancies. This saves about 18
        kB of data.
      </p>
      <p>The size of our table is just the sum of 2 to the power of the number of bits required for each square:</p>
      <pre
        class="rust"
      ><code>/// Compute the number of entries in a magic-movegen table required to store every element, given
/// the number of bits required for each square.
const fn table_size(bits_table: &amp;[u8; 64]) -&gt; usize {
    let mut i = 0;
    let mut total = 0;
    while i &lt; 64 { // POV you don&#39;t have iterators
        total += 1 &lt;&lt; bits_table[i];
        i += 1;
    }
    total
}</code></pre>
      <p>
        We also need to construct the masks for each square.
        <code>get_rook_masks</code> takes in a <code>Square</code> (hence the call to <code>transmute</code>) and builds
        the relevant occupancy mask for the square.
      </p>
      <pre
        class="rust"
      ><code>/// The bitwise masks for extracting the relevant pieces for a rook&#39;s attacks in a board, indexed
/// by the square occupied by the rook.
const ROOK_MASKS: [Bitboard; 64] = {
    let mut masks = [Bitboard::EMPTY; 64];
    let mut i = 0u8;
    while i &lt; 64 {
        masks[i as usize] = get_rook_mask(unsafe { transmute::&lt;u8, Square&gt;(i) });
        i += 1;
    }
    masks
};

/// Create the mask for the relevant bits in magic of a rook.
/// `sq` is the identifying the square that we want to generate the mask for.
const fn get_rook_mask(sq: Square) -&gt; Bitboard {
    // sequence of 1s down the same row as the piece to move, except on the ends
    let row_mask = 0x7E &lt;&lt; (sq as u8 &amp; !0x7);
    // sequence of 1s down the same col as the piece to move, except on the ends
    let col_mask = 0x0001_0101_0101_0100 &lt;&lt; (sq as u8 &amp; 0x7);
    // note: pieces at the end of the travel don&#39;t matter, which is why the masks aren&#39;t uniform

    // in the col mask or row mask, but not the piece to move
    Bitboard::new((row_mask | col_mask) &amp; !(1 &lt;&lt; sq as u64))
}</code></pre>
      <p>
        We now have enough to actually build the full set of attacks. We do this via brute force: for every possible
        occupancy, we calculate the set of legal moves, and then save the legal moves at the correct index.
      </p>
      <pre
        class="rust"
      ><code>/// The master table containing every attack that the rook can perform from every square under
/// every occupancy.
/// Borrowed by the individual [`AttacksLookup`]s in [`ROOK_LOOKUPS`].
const ROOK_ATTACKS_TABLE: [Bitboard; table_size(&amp;ROOK_BITS)] = construct_magic_table(
    &amp;ROOK_BITS,
    &amp;SAVED_ROOK_MAGICS,
    &amp;ROOK_MASKS,
    &amp;Direction::ROOK_DIRECTIONS,
);

/// Construct the master magic table for a rook or bishop based on all the requisite information.
///
/// # Inputs
///
/// - `bits`: For each square, the number of other squares which are involved in the calculation of
///   attacks from that square.
/// - `magics`: The magic numbers for each square.
/// - `masks`: The masks used for extracting the relevant squares for an attack on each starting
///   square.
/// - `dirs`: The directions in which the piece can move
const fn construct_magic_table&lt;const N: usize&gt;(
    bits: &amp;[u8; 64],
    magics: &amp;[u64; 64],
    masks: &amp;[Bitboard; 64],
    dirs: &amp;[Direction],
) -&gt; [Bitboard; N] {
    let mut table = [Bitboard::EMPTY; N];

    let mut i = 0;
    let mut table_offset = 0;

    while i &lt; 64 {
        let sq: Square = unsafe { transmute(i as u8) };
        let mask = masks[i];
        let magic = magics[i];
        let n_attacks_to_generate = 1 &lt;&lt; mask.len();

        let mut j = 0;
        while j &lt; n_attacks_to_generate {
            let occupancy = index_to_occupancy(j, mask);
            let attack = directional_attacks(sq, dirs, occupancy);
            let key = compute_magic_key(occupancy, magic, 64 - bits[i]);
            table[key + table_offset] = attack;
            j += 1;
        }

        table_offset += 1 &lt;&lt; bits[i];
        i += 1;
    }

    table
}</code></pre>
      <details>
        <summary>
          <p>
            <code>compute_magic_key</code> and the other helper functions called above can be implemented with some
            basic drudgery.
          </p>
        </summary>
        <pre class="rust"><code>/// Given some mask, create the occupancy [`Bitboard`] according to this index.
///
/// `index` must be less than or equal to 2 ^ (number of ones in `mask`).
/// This is equivalent to the parallel-bits-deposit (PDEP) instruction on x86 architectures.
const fn index_to_occupancy(index: usize, mask: Bitboard) -&gt; Bitboard {
    let mut result = 0u64;
    let num_points = mask.len();
    let mut editable_mask = mask.as_u64();
    // go from right to left in the bits of num_points,
    // and add an occupancy if something is there
    let mut i = 0;
    while i &lt; num_points {
        // make a bitboard which only occupies the rightmost square
        let occupier = 1 &lt;&lt; editable_mask.trailing_zeros();
        // remove the occupier from the mask
        editable_mask &amp;= !occupier;
        if (index &amp; (1 &lt;&lt; i)) != 0 {
            // the bit corresponding to the occupier is nonzero
            result |= occupier;
        }
        i += 1;
    }

    Bitboard::new(result)
}

/// Construct the squares attacked by the pieces at `sq` if it could move along the directions in
/// `dirs` when the board is occupied by the pieces in `occupancy`.
///
/// This is slow and should only be used for generatic magic bitboards (instead of for move
/// generation.
const fn directional_attacks(
    sq: Square,
    dirs: &amp;[Direction],
    occupancy: Bitboard,
) -&gt; Bitboard {
    // behold: much hackery for making this work as a const fn
    let mut result = Bitboard::EMPTY;
    let mut dir_idx = 0;
    while dir_idx &lt; dirs.len() {
        let dir = dirs[dir_idx];
        let mut current_square = sq;
        let mut loop_idx = 0;
        while loop_idx &lt; 7 {
            let next_square_int: i16 = current_square as i16
                + unsafe {
                    transmute::&lt;Direction, i8&gt;(dir) as i16
                };
            if next_square_int &lt; 0 || 64 &lt;= next_square_int {
                break;
            }
            let next_square: Square = unsafe { transmute(next_square_int as u8) };
            if next_square.chebyshev_to(current_square) &gt; 1 {
                break;
            }
            result = result.with_square(next_square);
            if occupancy.contains(next_square) {
                break;
            }
            current_square = next_square;
            loop_idx += 1;
        }
        dir_idx += 1;
    }

    result
}

/// Use magic hashing to get the index to look up attacks in a bitboard.
const fn compute_magic_key(occupancy: Bitboard, magic: u64, shift: u8) -&gt; usize {
    (occupancy.as_u64().wrapping_mul(magic) &gt;&gt; shift) as usize
}</code></pre>
      </details>
      <p><br /></p>
      <p>
        Lastly, we build each individual <code>AttacksLookup</code> with its references to
        <code>ROOK_ATTACKS_TABLE</code>.
      </p>
      <pre
        class="rust"
      ><code>/// The necessary information for generatng attacks for rook, indexed b the square occupied by
/// said rook.
const ROOK_LOOKUPS: [AttacksLookup; 64] = construct_lookups(
    &amp;ROOK_BITS,
    &amp;SAVED_ROOK_MAGICS,
    &amp;ROOK_MASKS,
    &amp;ROOK_ATTACKS_TABLE,
);

/// Construct the lookup tables for magic move generation by referencing an already-generated
/// attacks table.
const fn construct_lookups(
    bits: &amp;[u8; 64],
    magics: &amp;[u64; 64],
    masks: &amp;[Bitboard; 64],
    attacks_table: &amp;&#39;static [Bitboard],
) -&gt; [AttacksLookup; 64] {
    unsafe {
        let mut table: [MaybeUninit&lt;AttacksLookup&gt;; 64] = MaybeUninit::uninit().assume_init();

        let mut remaining_attacks = attacks_table;
        let mut i = 0;
        while i &lt; 64 {
            let these_attacks;
            (these_attacks, remaining_attacks) = remaining_attacks.split_at(1 &lt;&lt; bits[i]);
            table[i] = MaybeUninit::new(AttacksLookup {
                table: these_attacks,
                mask: masks[i],
                magic: magics[i],
                shift: 64 - bits[i],
            });

            i += 1;
        }

        transmute(table)
    }
}</code></pre>
      <p>
        In order to compute the moves for the rook, we work backwards, going from the
        <code>AttacksLookup</code> into the table. For performance, we perform unchecked array accesses. We can prove
        they’re always safe because <code>Square</code>s can only have values from 0 through 63, and we know our key
        generation code is producing a low enough index to not go out of bounds.
      </p>
      <pre class="rust"><code>pub fn rook_moves(occupancy: Bitboard, sq: Square) -&gt; Bitboard {
    let magic_data = unsafe { ROOK_LOOKUPS.get_unchecked(sq as usize) };
    let key = compute_magic_key(occupancy &amp; magic_data.mask, magic_data.magic, magic_data.shift);

    unsafe { *magic_data.table.get_unchecked(key) }

}</code></pre>
      <p>
        While you weren’t looking, I wrote some very similar code for writing the bishop moves-lookup table. In all,
        it’s about 300 lines of code.
      </p>
      <h2 id="insert-rust-compiler-speed-joke-here">&lt;insert Rust compiler speed joke here&gt;</h2>
      <p>
        It’s now time to compile our code. Running <code>cargo build</code>, we get to wait about 30 seconds until we
        encounter this beauty of an output:
      </p>
      <pre class="text"><code>~/C/fiddler (static_magic|✚2) $ cargo build
   Compiling fiddler v0.1.0 (/home/clayton/Chess/fiddler)
note: erroneous constant used
   --&gt; src/base/movegen/magic.rs:328:6
    |
328 |     &amp;ROOK_ATTACKS_TABLE,
    |      ^^^^^^^^^^^^^^^^^^

note: erroneous constant used
  --&gt; src/base/movegen/magic.rs:87:33
   |
87 |     get_attacks(occupancy, sq, &amp;ROOK_LOOKUPS)
   |                                 ^^^^^^^^^^^^

note: erroneous constant used
  --&gt; src/base/movegen/magic.rs:87:32
   |
87 |     get_attacks(occupancy, sq, &amp;ROOK_LOOKUPS)
   |                                ^^^^^^^^^^^^^

error: internal compiler error: no errors encountered even though `delay_span_bug` issued

error: internal compiler error: The deny lint should have already errored
   --&gt; /home/clayton/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:297:5
    |
297 | /     int_impl! {
298 | |         Self = i8,
299 | |         ActualT = i8,
300 | |         UnsignedT = u8,
...   |
315 | |         bound_condition = &quot;&quot;,
316 | |     }
    | |_____^
    |
    = note: delayed at compiler/rustc_const_eval/src/const_eval/machine.rs:634:26
               0: &lt;rustc_errors::HandlerInner&gt;::emit_diagnostic
               1: &lt;rustc_errors::Handler&gt;::delay_span_bug::&lt;rustc_span::span_encoding::Span, &amp;str&gt;
               2: &lt;rustc_const_eval::interpret::eval_context::InterpCx&lt;rustc_const_eval::const_eval::machine::CompileTimeInterpreter&gt;&gt;::statement
               3: rustc_const_eval::const_eval::eval_queries::eval_to_allocation_raw_provider
               4: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;
               5: &lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
               6: &lt;rustc_query_system::query::plumbing::execute_job_incr&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt&gt;::{closure#2}::{closure#2} as core::ops::function::FnOnce&lt;((rustc_query_impl::plumbing::QueryCtxt, rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;), rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
               7: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
               8: rustc_query_impl::query_impl::eval_to_allocation_raw::get_query_incr::__rust_end_short_backtrace
               9: &lt;rustc_const_eval::interpret::eval_context::InterpCx&lt;rustc_const_eval::const_eval::machine::CompileTimeInterpreter&gt;&gt;::eval_mir_constant
              10: &lt;rustc_const_eval::interpret::eval_context::InterpCx&lt;rustc_const_eval::const_eval::machine::CompileTimeInterpreter&gt;&gt;::push_stack_frame
              11: rustc_const_eval::const_eval::eval_queries::eval_to_allocation_raw_provider
              12: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;
              13: &lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              14: &lt;rustc_query_system::query::plumbing::execute_job_incr&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt&gt;::{closure#2}::{closure#2} as core::ops::function::FnOnce&lt;((rustc_query_impl::plumbing::QueryCtxt, rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;), rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              15: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
              16: rustc_query_impl::query_impl::eval_to_allocation_raw::get_query_incr::__rust_end_short_backtrace
              17: &lt;rustc_const_eval::interpret::eval_context::InterpCx&lt;rustc_const_eval::const_eval::machine::CompileTimeInterpreter&gt;&gt;::statement
              18: rustc_const_eval::const_eval::eval_queries::eval_to_allocation_raw_provider
              19: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;
              20: &lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              21: &lt;rustc_query_system::query::plumbing::execute_job_incr&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt&gt;::{closure#2}::{closure#2} as core::ops::function::FnOnce&lt;((rustc_query_impl::plumbing::QueryCtxt, rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;), rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              22: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
              23: rustc_query_impl::query_impl::eval_to_allocation_raw::get_query_incr::__rust_end_short_backtrace
              24: rustc_const_eval::const_eval::eval_queries::eval_to_allocation_raw_provider
              25: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;
              26: &lt;rustc_query_impl::query_impl::eval_to_allocation_raw::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              27: &lt;rustc_query_system::query::plumbing::execute_job_incr&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt&gt;::{closure#2}::{closure#2} as core::ops::function::FnOnce&lt;((rustc_query_impl::plumbing::QueryCtxt, rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 32]&gt;&gt;, false, false, false&gt;), rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;)&gt;&gt;::call_once
              28: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::DefaultCache&lt;rustc_middle::ty::ParamEnvAnd&lt;rustc_middle::mir::interpret::GlobalId&gt;, rustc_middle::query::erase::Erased&lt;[u8; 16]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
              29: rustc_query_impl::query_impl::eval_to_allocation_raw::get_query_incr::__rust_end_short_backtrace
              30: &lt;rustc_const_eval::interpret::eval_context::InterpCx&lt;rustc_mir_transform::const_prop::ConstPropMachine&gt;&gt;::eval_mir_constant
              31: &lt;rustc_mir_transform::const_prop_lint::ConstPropagator as rustc_middle::mir::visit::Visitor&gt;::visit_basic_block_data
              32: &lt;rustc_mir_transform::const_prop_lint::ConstProp as rustc_mir_transform::pass_manager::MirLint&gt;::run_lint
              33: rustc_mir_transform::mir_drops_elaborated_and_const_checked
              34: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::mir_drops_elaborated_and_const_checked::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 8]&gt;&gt;
              35: &lt;rustc_query_impl::query_impl::mir_drops_elaborated_and_const_checked::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, rustc_span::def_id::LocalDefId)&gt;&gt;::call_once
              36: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::VecCache&lt;rustc_span::def_id::LocalDefId, rustc_middle::query::erase::Erased&lt;[u8; 8]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
              37: rustc_query_impl::query_impl::mir_drops_elaborated_and_const_checked::get_query_incr::__rust_end_short_backtrace
              38: &lt;rustc_session::session::Session&gt;::time::&lt;(), rustc_interface::passes::analysis::{closure#2}&gt;
              39: rustc_interface::passes::analysis
              40: rustc_query_impl::plumbing::__rust_begin_short_backtrace::&lt;rustc_query_impl::query_impl::analysis::dynamic_query::{closure#2}::{closure#0}, rustc_middle::query::erase::Erased&lt;[u8; 1]&gt;&gt;
              41: &lt;rustc_query_impl::query_impl::analysis::dynamic_query::{closure#2} as core::ops::function::FnOnce&lt;(rustc_middle::ty::context::TyCtxt, ())&gt;&gt;::call_once
              42: rustc_query_system::query::plumbing::try_execute_query::&lt;rustc_query_impl::DynamicConfig&lt;rustc_query_system::query::caches::SingleCache&lt;rustc_middle::query::erase::Erased&lt;[u8; 1]&gt;&gt;, false, false, false&gt;, rustc_query_impl::plumbing::QueryCtxt, true&gt;
              43: rustc_query_impl::query_impl::analysis::get_query_incr::__rust_end_short_backtrace
              44: &lt;rustc_middle::ty::context::GlobalCtxt&gt;::enter::&lt;rustc_driver_impl::run_compiler::{closure#1}::{closure#2}::{closure#4}, core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;&gt;
              45: &lt;rustc_interface::interface::Compiler&gt;::enter::&lt;rustc_driver_impl::run_compiler::{closure#1}::{closure#2}, core::result::Result&lt;core::option::Option&lt;rustc_interface::queries::Linker&gt;, rustc_span::ErrorGuaranteed&gt;&gt;
              46: std::sys_common::backtrace::__rust_begin_short_backtrace::&lt;rustc_interface::util::run_in_thread_pool_with_globals&lt;rustc_interface::interface::run_compiler&lt;core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;, rustc_driver_impl::run_compiler::{closure#1}&gt;::{closure#0}, core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;&gt;::{closure#0}::{closure#0}, core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;&gt;
              47: &lt;&lt;std::thread::Builder&gt;::spawn_unchecked_&lt;rustc_interface::util::run_in_thread_pool_with_globals&lt;rustc_interface::interface::run_compiler&lt;core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;, rustc_driver_impl::run_compiler::{closure#1}&gt;::{closure#0}, core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;&gt;::{closure#0}::{closure#0}, core::result::Result&lt;(), rustc_span::ErrorGuaranteed&gt;&gt;::{closure#1} as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once::{shim:vtable#0}
              48: call_once&lt;(), dyn core::ops::function::FnOnce&lt;(), Output=()&gt;, alloc::alloc::Global&gt;
                         at /rustc/b2b34bd83192c3d16c88655158f7d8d612513e88/library/alloc/src/boxed.rs:1985:9
              49: call_once&lt;(), alloc::boxed::Box&lt;dyn core::ops::function::FnOnce&lt;(), Output=()&gt;, alloc::alloc::Global&gt;, alloc::alloc::Global&gt;
                         at /rustc/b2b34bd83192c3d16c88655158f7d8d612513e88/library/alloc/src/boxed.rs:1985:9
              50: thread_start
                         at /rustc/b2b34bd83192c3d16c88655158f7d8d612513e88/library/std/src/sys/unix/thread.rs:108:17
              51: start_thread
                         at ./nptl/pthread_create.c:444:8
              52: __GI___clone3
                         at ./misc/../sysdeps/unix/sysv/linux/x86_64/clone3.S:81

    = note: this error: internal compiler error originates in the macro `int_impl` (in Nightly builds, run with -Z macro-backtrace for more info)

note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&amp;template=ice.md

note: rustc 1.72.0-nightly (b2b34bd83 2023-06-06) running on x86_64-unknown-linux-gnu

note: compiler flags: --crate-type lib -C embed-bitcode=no -C debuginfo=2 -C incremental=[REDACTED] -C target_cpu=native

note: some of the compiler flags provided by cargo are hidden

query stack during panic:
end of query stack
error: could not compile `fiddler` (lib)</code></pre>
      <p>
        I accidentally found a compiler bug! I opened the issue for it
        <a href="https://github.com/rust-lang/rust/issues/112748">here</a>. I don’t know the exact cause for it yet, but
        I think it’s somehow related to constant evaluation. In any event, annotating
        <code>ROOK_ATTACKS_TABLE</code> with <code>#[allow(long_running_const_eval)]</code> seems to fix it.
      </p>
      <p>
        Running the compiler again, we find that our compile time has ballooned from about 3 seconds to 48 seconds.
        Almost all of that time is spent on generating <code>ROOK_ATTACKS_TABLE</code>.
      </p>
      <p>
        Interestingly enough, I wrote an exhaustive test of the magic table generation code, which does essentially the
        same thing as generating the table, except at runtime, and I found that it ran in 0.00 seconds. I suspect that
        the constant evaluator in Rust is just plain slow.
      </p>
      <h2 id="denouement">Denouement</h2>
      <p>
        Now that we’ve gotten the whole thing to compile, we can actually run a benchmark. In chess engines, the main
        measure of engine quality is Elo, a relative measure of engine performance.
      </p>
      <p>
        I threw the new version of Fiddler, with its compile-time generated lookup tables, against the older
        dynamically-generated ones, and here are my results:
      </p>
      <pre class="text"><code>Score of fiddler_const_magic vs fiddler_dynamic_magic: 5278 - 5003 - 4271 [0.509]
...      fiddler_const_magic playing White: 2766 - 2374 - 2136  [0.527] 7276
...      fiddler_const_magic playing Black: 2512 - 2629 - 2135  [0.492] 7276
...      White vs Black: 5395 - 4886 - 4271  [0.517] 14552
Elo difference: 6.6 +/- 4.7, LOS: 99.7 %, DrawRatio: 29.3 %
14566 of 30000 games finished.</code></pre>
      <p>We get a whole 6 Elo points - equivalent to a 1% improvement in the engine. At least it’s not a regression!</p>
    </main>
  </body>
</html>
